/* parser.y - LixeiraLang (codegen + suporte a variáveis genéricas) */

%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "codegen.h"

int yylex(void);
void yyerror(const char *s);

/* Pilhas para gerenciar rótulos de IF aninhados e dependendo labels */
#define IF_STACK_MAX 256
static char *if_else_stack[IF_STACK_MAX];
static char *if_end_stack[IF_STACK_MAX];
static int if_sp = 0;

static char *depend_stack[IF_STACK_MAX];
static int depend_sp = 0;

/* mapear destinos fixos */

   static const char *map_var_to_reg(const char *name) __attribute__((unused));
   static const char *map_var_to_reg(const char *name) {
  
    if (!name) return NULL;
    if (strcmp(name, "reciclavel") == 0) return "R2";
    if (strcmp(name, "organico") == 0)   return "R1";
    return NULL;
}

/* avaliar identificador em R3 (origem) - agora suporta LOADVAR para variáveis genéricas */
static void gen_eval_id_to_R3(const char *name) {
    if (strcmp(name, "reciclavel") == 0) {
        emit("MOV R3 R2");
    } else if (strcmp(name, "organico") == 0) {
        emit("MOV R3 R1");
    } else if (strcmp(name, "capReciclavel") == 0) {
        emit("LOADSENSOR R3 CAP_RECICLAVEL");
    } else if (strcmp(name, "capOrganico") == 0) {
        emit("LOADSENSOR R3 CAP_ORGANICO");
    } else if (strcmp(name, "tipoLixo") == 0) {
        emit("LOADSENSOR R3 TIPO_LIXO");
    } else {
        /* variável genérica: carregar da "memória" */
        emit("; LOAD variable %s -> R3", name);
        emit("LOADVAR R3 %s", name);
    }
}

/* armazenar R3 em variável destino */
static void gen_store_R3_to_var(const char *name) {
    if (strcmp(name, "reciclavel") == 0) {
        emit("; STORE R3 -> reciclavel (R2)");
        emit("MOV R2 R3");
    } else if (strcmp(name, "organico") == 0) {
        emit("; STORE R3 -> organico (R1)");
        emit("MOV R1 R3");
    } else {
        emit("; STOREVAR %s <- R3", name);
        emit("STOREVAR %s R3", name);
    }
}

/* checar lixo -> R3 */
static void gen_eval_checar_to_R3(void) {
    emit("LOADSENSOR R3 TIPO_LIXO");
}

/* comparação/arithmetic helpers (geram operações que assumem R4=left, R3=right e escrevem resultado em R3) */
static void gen_cmp_result_in_R3(const char *op) {
    if (strcmp(op, "==") == 0) emit("EQ R3 R4 R3");
    else if (strcmp(op, "!=") == 0) emit("NE R3 R4 R3");
    else if (strcmp(op, "<") == 0) emit("LT R3 R4 R3");
    else if (strcmp(op, ">") == 0) emit("GT R3 R4 R3");
    else if (strcmp(op, "<=") == 0) emit("LE R3 R4 R3");
    else if (strcmp(op, ">=") == 0) emit("GE R3 R4 R3");
    else emit("SET R3 0");
}

static void gen_arith_with_R4_R3(const char *op) {
    if (strcmp(op, "+") == 0) emit("ADD R3 R4 R3");
    else if (strcmp(op, "-") == 0) emit("SUB R3 R4 R3");
    else if (strcmp(op, "*") == 0) emit("MUL R3 R4 R3");
    else if (strcmp(op, "/") == 0) emit("DIV R3 R4 R3");
    else emit("SET R3 0");
}

%}

%union {
    int num;
    char *str;
}

/* tokens */
%token <num> NUMERO
%token <str> ID
%token CHECAR_LIXO ADD_ORGANICO ADD_RECICLAVEL ESVAZIAR_ORGANICO ESVAZIAR_RECICLAVEL
%token MOSTRA_AE SEPA DEPENDENDO NAOSEPA LOOP
%token CAP_RECICLAVEL CAP_ORGANICO TIPO_LIXO
%token IGUAL DIFERENTE MENOR_IGUAL MAIOR_IGUAL MENOR MAIOR
%token ATRIBUICAO MAIS MENOS MULT DIV
%token ABRE_PAR FECHA_PAR ABRE_CHAVE FECHA_CHAVE PONTO_VIRGULA

%type <num> expressao expressao_logica comparacao adicao multiplicacao primaria

/* precedências */
%left MAIS MENOS
%left MULT DIV
%left MENOR MAIOR MENOR_IGUAL MAIOR_IGUAL
%left IGUAL DIFERENTE

%%

programa:
      /* vazio */
    | programa comando
    ;

comando:
      atribuicao PONTO_VIRGULA
    | acao PONTO_VIRGULA
    | condicional
    | loop
    ;

atribuicao:
      ID ATRIBUICAO expressao
    {
        /* expressão deixou resultado em R3 */
        gen_store_R3_to_var($1);
        free($1);
    }
    ;

acao:
      CHECAR_LIXO ABRE_PAR FECHA_PAR
        {
          emit("; action ChecarOLixo()");
          emit("LOADSENSOR R3 TIPO_LIXO");
        }
    | ADD_ORGANICO ABRE_PAR FECHA_PAR
        {
            emit("; action ADD_ORGANICO -> INC R1");
            emit("INC R1");
            emit("PRINT R1");
        }
    | ADD_RECICLAVEL ABRE_PAR FECHA_PAR
        {
            emit("; action ADD_RECICLAVEL -> INC R2");
            emit("INC R2");
            emit("PRINT R2");
        }
    | ESVAZIAR_ORGANICO ABRE_PAR FECHA_PAR
        {
            emit("; action ESVAZIAR_ORGANICO -> SET R1 0");
            emit("SET R1 0");
            emit("PRINT R1");
        }
    | ESVAZIAR_RECICLAVEL ABRE_PAR FECHA_PAR
        {
            emit("; action ESVAZIAR_RECICLAVEL -> SET R2 0");
            emit("SET R2 0");
            emit("PRINT R2");
        }
    | MOSTRA_AE ABRE_PAR expressao FECHA_PAR
        {
            emit("; action mostraAe -> PRINT R3");
            emit("PRINT R3");
        }
    ;

/* CONDICIONAL (IF / ELSEIF / ELSE) com mid-rule actions e pilha de labels */
condicional:
    SEPA ABRE_PAR expressao FECHA_PAR
        {
            /* cria labels para else e end; expressão já deixou resultado em R3 */
            char *Lelse = new_label();
            char *Lend  = new_label();
            if (if_sp >= IF_STACK_MAX) {
                yyerror("too many nested ifs");
                YYABORT;
            }
            if_else_stack[if_sp] = Lelse;
            if_end_stack[if_sp]  = Lend;
            if_sp++;
            emit("; if start - if_sp=%d", if_sp);
            /* se R3 == 0 pula para else */
            emit("JZ R3 %s", Lelse);
        }
    ABRE_CHAVE programa FECHA_CHAVE
        {
            /* após then: pular para end e colocar label else */
            emit("JMP %s", if_end_stack[if_sp-1]);
            emit("LABEL %s", if_else_stack[if_sp-1]);
        }
    cond_dependendo_opt
    naosepa_opt
    {
        /* final do if: coloca label end e limpa pilha */
        emit("LABEL %s", if_end_stack[if_sp-1]);
        free(if_else_stack[if_sp-1]);
        free(if_end_stack[if_sp-1]);
        if_else_stack[if_sp-1] = NULL;
        if_end_stack[if_sp-1] = NULL;
        if_sp--;
    }
    ;

/* 'dependendo' (elsif) — pode haver vários.
   Implementação: para cada 'dependendo (expr) { body }' emitimos:
     - JZ R3 Lnext   (se expr==0 salta para Lnext)
     - body
     - JMP Lend
     - LABEL Lnext
*/
cond_dependendo_opt:
      /* vazio */
    | cond_dependendo_opt DEPENDENDO ABRE_PAR expressao FECHA_PAR
        {
            /* cria label que será colocado após o body */
            char *Lnext = new_label();
            if (depend_sp >= IF_STACK_MAX) {
                yyerror("too many nested dependendo");
                YYABORT;
            }
            depend_stack[depend_sp++] = Lnext;
            /* se expr == 0 pula para Lnext */
            emit("; dependendo: if not (expr) jump to next dependendo");
            emit("JZ R3 %s", Lnext);
        }
      ABRE_CHAVE programa FECHA_CHAVE
        {
            /* body acabado: pular para end e colocar LABEL Lnext (top of depend_stack) */
            if (depend_sp <= 0) {
                /* shouldn't happen */
            } else {
                char *Lnext2 = depend_stack[--depend_sp];
                emit("JMP %s", if_end_stack[if_sp-1]);
                emit("LABEL %s", Lnext2);
                free(Lnext2);
            }
        }
    ;

/* else opcional */
naosepa_opt:
      /* vazio */
    | NAOSEPA ABRE_CHAVE programa FECHA_CHAVE
        {
            /* corpo do else já foi emitido pelo 'programa' */
        }
    ;

loop:
    LOOP ABRE_PAR expressao FECHA_PAR ABRE_CHAVE programa FECHA_CHAVE
    {
        /* implementa laço simples: assume expressao deixou resultado em R3;
           aqui criamos labels e montamos a estrutura */
        char *Lstart = new_label();
        char *Lend = new_label();
        emit("LABEL %s", Lstart);
        /* condição: se R3 == 0 sair */
        emit("JZ R3 %s", Lend);
        /* corpo já emitido */
        emit("JMP %s", Lstart);
        emit("LABEL %s", Lend);
        free(Lstart);
        free(Lend);
    }
    ;

expressao:
    expressao_logica { $$ = $1; }
    ;

expressao_logica:
    comparacao { $$ = $1; }
    | expressao_logica IGUAL comparacao
        {
            emit("; EQ operation");
            emit("MOV R4 R3"); /* left -> R4 */
            /* comparacao produced R3 for right */
            gen_cmp_result_in_R3("==");
        }
    | expressao_logica DIFERENTE comparacao
        {
            emit("; NE operation");
            emit("MOV R4 R3");
            gen_cmp_result_in_R3("!=");
        }
    ;

comparacao:
    adicao { $$ = $1; }
    | comparacao MENOR adicao
        {
            emit("; LT operation");
            emit("MOV R4 R3");
            gen_cmp_result_in_R3("<");
        }
    | comparacao MAIOR adicao
        {
            emit("; GT operation");
            emit("MOV R4 R3");
            gen_cmp_result_in_R3(">");
        }
    | comparacao MENOR_IGUAL adicao
        {
            emit("; LE operation");
            emit("MOV R4 R3");
            gen_cmp_result_in_R3("<=");
        }
    | comparacao MAIOR_IGUAL adicao
        {
            emit("; GE operation");
            emit("MOV R4 R3");
            gen_cmp_result_in_R3(">=");
        }
    ;

adicao:
    multiplicacao { $$ = $1; }
    | adicao MAIS multiplicacao
        {
            emit("; ADD");
            emit("MOV R4 R3"); /* left -> R4 */
            gen_arith_with_R4_R3("+");
        }
    | adicao MENOS multiplicacao
        {
            emit("; SUB");
            emit("MOV R4 R3");
            gen_arith_with_R4_R3("-");
        }
    ;

multiplicacao:
    primaria { $$ = $1; }
    | multiplicacao MULT primaria
        {
            emit("; MUL");
            emit("MOV R4 R3");
            gen_arith_with_R4_R3("*");
        }
    | multiplicacao DIV primaria
        {
            emit("; DIV");
            emit("MOV R4 R3");
            gen_arith_with_R4_R3("/");
        }
    ;

primaria:
    NUMERO
        {
            emit("; load literal");
            emit("SET R3 %d", $1);
            $$ = $1;
        }
    | ID
        {
            gen_eval_id_to_R3($1);
            free($1);
            $$ = 0;
        }
    | CAP_RECICLAVEL
        {
            emit("LOADSENSOR R3 CAP_RECICLAVEL");
            $$ = 0;
        }
    | CAP_ORGANICO
        {
            emit("LOADSENSOR R3 CAP_ORGANICO");
            $$ = 0;
        }
    | TIPO_LIXO
        {
            emit("LOADSENSOR R3 TIPO_LIXO");
            $$ = 0;
        }
    | ABRE_PAR expressao FECHA_PAR
        {
            $$ = $2;
        }
    | CHECAR_LIXO ABRE_PAR FECHA_PAR
        {
            gen_eval_checar_to_R3();
            $$ = 0;
        }
    ;

%%

void yyerror(const char *s) {
    fprintf(stderr, "Erro sintático: %s\n", s);
}

int main(int argc, char *argv[]) {
    const char *outname = "program.asm";
    codegen_init(outname);
    printf("LixeiraLang - gerando assembly em %s\n", outname);

    if (yyparse() == 0) {
        printf("Analise concluida: sintaxe aceita.\n");
    } else {
        printf("Analise concluida: erros detectados.\n");
    }

    codegen_close();
    return 0;
}